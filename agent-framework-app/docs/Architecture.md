# **AI Workflow Builder Fullstack Architecture Document**

## **1\. Introduction**

This document outlines the complete fullstack architecture for the AI Workflow Builder, including backend systems, frontend implementation, and their integration. It serves as the single source of truth for AI-driven development, ensuring consistency across the entire technology stack and strict adherence to the **Microsoft Agent Framework**.

### **Change Log**

| Date | Version | Description | Author |
| :---- | :---- | :---- | :---- |
| 2025-10-03 | 1.0 | Initial architectural document | Winston |

## **2\. High-Level Architecture**

The system uses a decoupled three-tier architecture: a React frontend, a FastAPI backend, and a Docker-based secure execution engine. This separation of concerns provides scalability, security, and maintainability.

### **Platform and Infrastructure Choice**

* **Platform:** Docker for containerization of the backend and execution engine.  
* **Hosting:** The platform is designed to be cloud-agnostic and can be deployed on any major cloud provider (AWS, Azure, GCP) that supports Docker containers and PostgreSQL.  
* **Key Services:** A virtual private server for hosting containers, a managed PostgreSQL database, and an object store for any potential file-based checkpointing.

### **Repository Structure**

* **Structure:** Monorepo. This is ideal for a full-stack application with shared logic (like types), simplifying dependency management and ensuring consistency.  
* **Monorepo Tool:** npm/pnpm/yarn workspaces will be used.

### **High-Level Architecture Diagram**

graph TD  
    subgraph User  
        A\[Browser\]  
    end

    subgraph Frontend (React SPA)  
        B\[UI Components\]  
        C\[State Management\]  
        D\[API Client\]  
    end

    subgraph Backend (FastAPI Server)  
        E\[API Endpoints\]  
        F\[Orchestration Logic & Meta-Agent\]  
        G\[Database (PostgreSQL)\]  
    end

    subgraph Secure Execution Engine  
        H\[Docker Sandbox\]  
        I\[Workflow Runner\]  
        J\[Checkpoint Manager\]  
    end

    A \--\> B  
    B \--\> C  
    C \--\> D  
    D \<--\> E

    E \--\> F  
    F \<--\> G  
    F \--\> H

    H \--\> I  
    I \--\> J  
    I \-- Streams Events \--\> F

## **3\. Tech Stack**

This is the definitive technology selection for the entire project. All development must use these exact versions.

| Category | Technology | Justification & Framework Reference |
| :---- | :---- | :---- |
| **Backend Language** | Python 3.11+ | Required by the prompt and the Microsoft Agent Framework. |
| **Backend Framework** | FastAPI | High-performance, async-native framework ideal for handling WebSockets and long-running agent tasks. |
| **Core AI Framework** | **Microsoft Agent Framework** | The non-negotiable core of the backend. All agent/workflow logic will use its WorkflowBuilder, ChatClientAgent, etc. |
| **Frontend Framework** | React (with TypeScript) | Robust library for building the complex, interactive split-screen UI. |
| **Database** | PostgreSQL | Reliable relational database for storing user accounts, workflow definitions, and serialized AgentThread states for checkpointing. |
| **Code Editor (UI)** | Monaco Editor | Provides a rich, VS Code-like editing experience for Python in the browser. |
| **Workflow Visualizer** | React Flow w/ Mermaid.js | React Flow provides the interactive canvas (drag, drop, connect), while Mermaid.js will render the graph generated by WorkflowViz. |
| **Execution Sandbox** | Docker | Provides essential process, network, and filesystem isolation for running user-generated code securely. |
| **Observability** | OpenTelemetry | As specified in the agent-framework.md documentation, for built-in tracing of workflow.run and executor.process spans. |
| **Real-time Comms** | WebSockets | Used for streaming WorkflowEvent data from the backend to the frontend console during execution. |
| **UI Components** | Shadcn/UI & Tailwind CSS | A modern, accessible component library that allows for rapid UI development and easy theming. |

## **4\. Data Models**

These TypeScript interfaces will be defined in a shared package within the monorepo for use by both the frontend and the backend API.

// in packages/shared/src/types.ts

export interface User {  
  id: string;  
  email: string;  
  createdAt: Date;  
}

export interface Workflow {  
  id: string;  
  name: string;  
  code: string; // The Python script  
  ownerId: string;  
  createdAt: Date;  
  updatedAt: Date;  
}

export interface WorkflowExecution {  
  id: string;  
  workflowId: string;  
  status: 'running' | 'paused' | 'completed' | 'failed';  
  latestCheckpointId?: string;  
}

## **5\. API Specification (OpenAPI 3.0)**

This defines the contract between the frontend and the FastAPI backend.

\# Simplified OpenAPI 3.0 Spec  
openapi: 3.0.0  
info:  
  title: AI Workflow Builder API  
  version: 1.0.0  
paths:  
  /api/generate-workflow:  
    post:  
      summary: Generates a workflow from a natural language prompt.  
      requestBody:  
        required: true  
        content:  
          application/json:  
            schema: { type: object, properties: { prompt: { type: string } } }  
      responses:  
        '200':  
          description: OK  
          content:  
            application/json:  
              schema: { type: object, properties: { code: { type: string }, mermaidDefinition: { type: string } } }  
    
  /api/sync/visual-to-code:  
    post:  
      summary: Updates Python code based on a visual graph structure.  
      \# ... request/response definitions  
        
  /api/sync/code-to-visual:  
    post:  
      summary: Generates a new visual diagram from Python code.  
      \# ... request/response definitions

  /api/execute-workflow:  
    post:  
      summary: Executes a workflow and initiates event streaming.  
      \# ... request/response definitions

  /api/workflows:  
    post:  
      summary: Saves a new workflow. (Authenticated)  
    get:  
      summary: Lists saved workflows. (Authenticated)

## **6\. Unified Project Structure (Monorepo)**

/ai-workflow-builder/  
|-- /apps/  
|   |-- /frontend/         \# React SPA (Vite)  
|   |   |-- /src/  
|   |   |   |-- /components/ \# UI components  
|   |   |   |-- /features/   \# Feature-sliced logic (e.g., editor, visualizer)  
|   |   |   |-- /hooks/  
|   |   |   |-- /services/   \# API client  
|   |   |   \`-- App.tsx  
|   |   \`-- package.json  
|   \`-- /backend/          \# FastAPI Server  
|       |-- /app/  
|       |   |-- /api/        \# API routers  
|       |   |-- /core/       \# Core logic (NLP processing, code gen)  
|       |   |-- /models/     \# Database models (e.g., using SQLModel)  
|       |   |-- /services/   \# Services (e.g., execution\_service)  
|       |   \`-- main.py  
|       |-- Dockerfile  
|       \`-- requirements.txt  
|-- /packages/  
|   |-- /shared/           \# Shared TypeScript types and constants  
|   \`-- /ui/               \# Shared React components (from Shadcn/UI)  
|-- /execution-engine/  
|   |-- Dockerfile         \# Dockerfile for the secure sandbox  
|   \`-- runner.py          \# Script to execute workflow code inside the sandbox  
|-- package.json             \# Root package.json with workspace definitions  
\`-- README.md

## **7\. Backend Architecture**

* **API Layer:** FastAPI routers will define the API endpoints. They will handle request validation (using Pydantic) and delegate to the orchestration layer.  
* **Orchestration Layer:** This is the core of the backend. It will house the "meta-agent" responsible for FR1. This service will take user prompts, interact with an LLM via ChatClientAgent to get a structured plan, and then generate the Python code and WorkflowViz output.  
* **Execution Service:** This service will manage the lifecycle of the secure execution engine. It will receive code, spin up a Docker container, pass the code to it, and establish a communication channel (e.g., Redis pub/sub or a direct WebSocket proxy) to stream WorkflowEvent data back.  
* **Database Access:** A repository pattern will be used to abstract database operations, managed by a library like SQLModel or SQLAlchemy.

## **8\. Frontend Architecture**

* **Component Architecture:** The UI will be built with functional React components and hooks. A feature-sliced directory structure will be used to organize logic.  
* **State Management:** For managing the complex state of the editor, visualizer, and console, a robust state management library like **Zustand** or **Redux Toolkit** will be used. This is essential for handling the real-time two-way sync.  
* **API Integration:** An API client service will be created to handle all communication with the backend. It will use fetch or axios for REST calls and the native WebSocket API for real-time event streaming.

## **9\. Secure Execution Engine Architecture**

* **Isolation:** The engine is built on Docker. The execution-engine/Dockerfile will define a minimal Python environment with only the agent-framework and its direct dependencies installed.  
* **Invocation:** The backend's Execution Service will use the Docker SDK for Python to programmatically start and manage containers. The user's code will be mounted into the container or passed via stdin.  
* **Communication:** The runner.py script inside the container will execute the user's workflow code. It will capture all WorkflowEvent objects produced by InProcessExecution.StreamAsync and serialize them to stdout as JSON lines.  
* **Security Policies:**  
  * **Network:** Docker network policies will be set to none by default. Any necessary external API calls must be explicitly declared and will be proxied through a secure gateway managed by the backend.  
  * **Filesystem:** The container's root filesystem will be read-only. A temporary, in-memory volume (tmpfs) will be mounted for any ephemeral file needs.  
  * **Resources:** Each container will be launched with strict CPU and memory limits (e.g., 1 CPU, 512MB RAM) and a timeout (e.g., 60 seconds) to prevent abuse.

## **10\. Observability Plan**

As per the agent-framework.md documentation, we will integrate OpenTelemetry.

* **Configuration:** The setup\_observability() function will be called at the startup of the FastAPI backend and the runner.py script in the execution engine.  
* **Tracing:** This will automatically create traces for:  
  * workflow.run: Capturing the full execution of a user's workflow inside the sandbox.  
  * executor.process: Capturing the execution of each individual node within the workflow.  
* **Metrics & Logs:** We will configure exporters to send this telemetry data to a suitable backend (like Jaeger for local development or Datadog/Azure Monitor in production) for analysis and alerting.

This completes the architectural plan.

*transforming back into the BMad Orchestrator...*

The comprehensive planning phase is now complete. In YOLO mode, our specialized agents have produced the following critical documents:

1. docs/brief.md: The **Project Brief**, which establishes the project's vision, goals, and high-level scope.  
2. docs/prd.md: The **Product Requirements Document**, which details the functional/non-functional requirements, epics, and user stories.  
3. docs/front-end-spec.md: The **UI/UX Specification**, which provides the design blueprint for the frontend application.  
4. docs/architecture.md: The **Fullstack Architecture Document**, which serves as the definitive technical plan for the entire system.

**All planning artifacts are finished.**

### **Next Steps: Transition to Development**

The BMad workflow now moves from the high-level planning environment to the development environment (your IDE). Here is your path forward:

1. **Save Artifacts:** Copy the content of the four generated documents into your local project's docs/ directory.  
2. **Move to IDE:** Open your project in your preferred IDE (like VS Code with Copilot or Cursor).  
3. **Shard Documents:** The PRD and Architecture documents are large. To make them usable for the development agents, you must shard them. In your IDE, invoke the Product Owner agent (\*agent po) and give the command \*shard-doc docs/prd.md. Repeat for \*shard-doc docs/architecture.md. This will break them into smaller, manageable files.  
4. **Begin Development Cycle:** Start the story implementation loop by invoking the Scrum Master agent (\*agent sm) and running the \*create command. This will create the first story (1.1 Project Scaffolding & Setup) from the sharded documents, and you can then hand it to the dev agent for implementation.

The project is now fully planned and ready for execution. Your AI development team awaits your direction in the IDE.